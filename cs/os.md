# 운영체제 면접 질문

## 1. 운영체제의 역할

<details>
<summary><b>운영체제에 대해 설명해주세요</b></summary>
  
> 사용자가 프로그램을 실행할 때, 자원을 할당하고 프로세스와 스레드를 관리해 하드웨어를 직접 제어하지 않고도 효율적이고 안전하게 이용할 수 있도록 하는 소프트웨어입니다.
</details>

<details>
<summary><b>운영체제의 역할에 대해 설명해주세요</b></summary>
  
> 운영체제는 크게 4가지 역할을 수행합니다.
> 1) **CPU 스케줄링** - 실행 중인 모든 프로그램들이 공정하고 합리적으로 CPU를 할당받도록 할당 순서와 사용 시간 결정
> 2) **메모리 관리** - 새로 실행하는 프로그램을 메모리에 적재하고, 종료된 프로그램을 메모리에서 삭제 (가상 메모리 기술 활용)
> 3) **파일 시스템 관리** - 파일 생성, 삭제, 읽기, 쓰기 등과 같은 작업을 지원하며 보조기억장치를 관리
> 4) **프로세스 및 스레드 관리** - 프로세스와 스레드의 생성, 종료를 관리하고 여러 작업이 동시에 원활히 수행되도록 실행 순서를 조정
</details>

<details>
<summary><b>커널에 대해 설명해주세요</b></summary>
  
> 커널은 운영체제의 핵심 부분으로, 하드웨어와 응용 프로그램 간의 중재자 역할을 합니다.  
> 응용 프로그램은 **시스템 콜**을 호출하여 운영체제 서비스를 이용할 수 있는데, 이때 커널은 **이중 모드**를 운영해 응용 프로그램이 안전하고 효율적으로 시스템 자원을 사용할 수 있도록 합니다.
</details>

<details>
<summary><b>시스템 콜에 대해 설명해주세요</b></summary>
  
> 운영체제의 서비스를 받기 위한 수단으로 호출 가능한 함수의 형태를 가지며, 소프트웨어 인터럽트의 일종입니다.  
</details>

<details>
<summary><b>이중 모드에 대해 설명해주세요</b></summary>
  
> 응용 프로그램이 커널에서 관리하는 자원에 직접 접근하지 못하도록 **사용자 모드**와 **커널 모드**로 구분하여 실행하는 것을 이중 모드라고 합니다.  
> **사용자 모드**는 운영체제 서비스를 제공받을 수 없는 실행 모드로 자원에 접근할 수 없습니다.  
> **커널 모드**는 운영체제 서비스를 제공받을 수 있는 실행 모드로 자원에 접근할 수 있습니다.  
> 이러한 두 모드의 전환은 **인터럽트**가 발생했을 때 일어납니다.

> ### 인터럽트 발생 시 모드 전환 과정
> 1) 인터럽트 발생 시, CPU는 수행 중인 작업을 백업 후 커널 모드로 전환
> 2) 시스템 콜 등 인터럽트를 처리하기 위한 코드 실행
> 3) 사용자 모드로 재전환
</details>

## 2. 프로세스와 스레드

<details>
<summary><b>프로세스에 대해서 설명해주세요</b></summary>
  
> 프로세스는 컴퓨터에서 실행되고 있는 프로그램을 말합니다.
> 프로세스는 코드, 데이터, 스택, 힙 영역의 독립된 메모리 영역을 할당받습니다.  
> 각 프로세스는 독립된 메모리 영역이 있기 때문에 다른 프로세스와 자원을 공유하기 위해서는 **IPC**를 이용해야 합니다.
</details>

<details>
<summary><b>프로세스의 메모리 영역에 대해서 설명해주세요</b></summary>
  
> 1) **코드 영역** - CPU가 읽고 실행할 명령어가 저장되는 공간으로 read-only 입니다.
> 2) **데이터 영역** - static 변수나 전역 변수가 저장되는 공간입니다.
> 3) **힙 영역** - 사용자가 직접 할당 가능한 공간이며, 사용이 끝났다면 메모리 누수가 발생하지 않도록 할당한 공간을 반환해야 합니다.  
이를 위해 Java와 같은 일부 프로그래밍 언어에서는 가비지 컬렉션 기능을 제공하기도 합니다.
> 4) **스택 영역** - 함수의 실행이 끝나면 사라지는 매개변수, 지역 변수와 같이 일시적으로 사용할 값들이 저장되는 공간입니다.  
또한, Java에서 문제 발생 지점을 추적해 디버깅 할 수 있게 하는 스택 트레이스가 저장될 수 있습니다.
</details>

<details>
<summary><b>PCB(Process Control Block)에 대해서 설명해주세요</b></summary>
  
> 운영체제가 다수의 프로세스를 관리하기 위해 프로세스를 식별할 수 있는 정보들을 구조체의 형태로 메모리의 커널 영역에 저장하는데, 이것을 PCB라고 합니다.
> PCB에는 PID, CPU 스케줄링 우선순위 정보, 프로세스 상태 등 프로세스와 관련된 다양한 정보가 있습니다.  
> PCB는 프로세스가 메모리에 적재됐을 때 커널 영역에 생성되고 프로세스가 종료되면 폐기됩니다.
</details>

<details>
<summary><b>문맥 교환(Context Switching)에 대해서 설명해주세요</b></summary>
  
> CPU가 기존 프로세스의 문맥을 PCB에 백업하고, PCB에서 문맥을 복구하여 프로세스의 수행을 제개하는 것을 문맥 교환이라고 합니다.
> 보통 인터럽트가 발생하거나, 실행 중인 CPU 사용 허가시간을 모두 소모하거나, 입출력을 위해 대기해야 하는 경우에 문맥 교환이 발생합니다.  
> ※문맥이란?  
> 프로세스의 수행을 재개하기 위해 기억해야 할 정보로 레지스터 값, 메모리 정보, 실행을 위해 열였던 파일 등이 있다.
</details>

<details>
<summary><b>문맥 교환(Context Switching)은 많이 반복할 수록 좋을까요?</b></summary>
  
> 빈번한 문맥 교환은 문맥 교환 오버헤드의 발생으로 (실제 작업보다 PCB에 문맥을 백업하고 복구하는데에 CPU 시간을 사용하게 되므로) 효율성이 좋지 않습니다.  
> 또한, 캐시 미스율이 증가하므로 전체적인 처리 속도가 저하될 수 있습니다.
</details>

<details>
<summary><b>블로킹 입출력과 논블로킹 입출력의 차이점에 대해 설명해주세요</b></summary>
  
> **블로킹 입출력**은 프로세스가 입출력 작업을 시작하면 입출력이 완료될 때까지 대기하지만, **논블로킹 입출력**은 입출력이 왼료되기를 기다리지 않고 바로 다음 명령을 수행합니다.
</details>

<details>
<summary><b>멀티프로세스와 멀티스레드에 대해 설명해주세요</b></summary>
  
> **멀티프로세스**는 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하는 것입니다.  
> 프로세스는 각각 독립된 메모리 영역을 갖고 있어서 한 프로세스에 문제가 발생해도 다른 프로세스에 지장이 거의 없다는 장점이 있지만  
> 작업하는 프로세스가 많을 수록 문맥 교환 오버헤드로 성능이 저하될 수 있습니다.

> **멀티스레드**는 하나의 프로세스에서 여러 스레드를 구성해 하나의 작업을 수행하는 것입니다.  
> 각각의 스레드는 메모리에서 스택 영역만 따로 할당받고, 나머지 코드, 데이터, 힙 영역은 프로세스의 자원을 공유하기 때문에 문맥 교환 오버헤드가 프로세스에 비해 작다는 장점이 있지만
> 프로세스의 자원을 공유하기 때문에 한 스레드에서 문제가 발생하면 프로세스 전체의 문제가 될 수 있다는 단점이 있습니다.
</details>

<details>
<summary><b>IPC(Inter-Process Communication)에 대해 설명해주세요</b></summary>
  
> 기본적으로 자원을 공유하지 않는 프로세스 간에 데이터를 주고 받을 수 있게 하기 위한 통신을 IPC라고 합니다.  
> IPC가 이루어지는 방식에는 공유 메모리와 메시지 전달 방식이 있습니다.  

> **공유 메모리** 방식은 프로세스 간에 공유하는 메모리 영역을 토대로 데이터를 주고받는 방식입니다.  
> 각 프로세스가 마치 자신의 메모리 영역을 읽고 쓰는 것처럼 통신하기 때문에 커널의 개입이 거의 없고, 그렇기 때문에 메시지 전달 방식보다 통신 속도가 빠릅니다.  
> 하지만, 공유 메모리 영역에 대한 레이스 컨디션 문제가 발생할 수 있습니다.

> **메시지 전달** 방식은 프로세스 간에 주고 받을 데이터가 커널을 거쳐 송수신되는 방식입니다.  
> 메시지 기반 IPC는 커널을 통해 데이터를 송수신하기 때문에, 통신 속도는 공유 메모리보다 느리지만 커널의 도움을 더 적극적으로 받을 수 있어서 레이스 컨디션, 동기화 등의 문제에 대해 고려하는 경우가 적습니다.  
> 메시지 기반 IPC에는 파이프, 소켓, RPC 등이 있습니다.

>  <details>
>  <summary><b>파이프</b></summary>
>
>  **익명 파이프 (unnamed pipe)**  
>  두 개의 프로세스 중 프로세스 A는 쓰기만 가능하고 프로세스 B는 읽기만 가능한 단방향 통신만 지원하기 때문에 양방향 통신을 위해서는 2개의 파이프를 사용해야 합니다.  
>  또한, 부모 프로세스와 자식 프로세스 간에만 통신할 수 있습니다.  
>
>  **지명 파이프 (named pipe)**  
>  FIFO라고도 불리며, 양방향 통신을 지원합니다.  
>  또한, 부모와 자식 프로세스 간 뿐만 아니라, 임의의 프로세스 간에도 통신할 수 있습니다.
>  </details>

>  <details>
>  <summary><b>RPC(Remote Procedure Call)</b></summary>
>    
>  다른 프로세스나 원격 서버에 있는 함수를 로컬 함수처럼 호출할 수 있게 해주는 통신 방식입니다.  
>  인터페이스를 기준으로 통신하기 때문에 특정 프로그래밍 언어나 플랫폼에 의존적이지 않습니다.  
>  또한, JSON으로 데이터를 직렬화/역직렬화하는 REST API에 비해 바이너리 포맷으로 데이터를 주고 받는 RPC가 더 빠른 전송 속도를 제공합니다.
>  </details>
</details>

## 3. 동기화와 교착 상태

<details>
<summary><b>레이스 컨디션이 무엇인가요?</b></summary>
  
> 여러 개의 프로세스 또는 스레드가 동시에 임계 구역에 진입해 발생하는 상황을 레이스 컨디션이라고 합니다.
</details>

<details>
<summary><b>레이스 컨디션을 방지하기 위한 방법은 뭘까요?</b></summary>
  
> 프로세스와 스레드가 **동기화**되어야 합니다.  
> 동기화란 **상호 배제**와 **실행 순서 제어** 조건을 준수하는 것을 의미합니다.

> **상호 배제** - 임계 구역에 하나의 프로세스 및 스레드만 접근하기  
> **실행 순서 제어** - 임계 구역에 대한 접근이 무기한 연기되지 않고 올바른 순서로 접근하기 
</details>

<details>
<summary><b>동기화 기법에 대해 설명해주세요</b></summary>
  
> **뮤텍스(MUTual EXclusion) 락**은 한 번에 하나의 스레드만 임계 구역에 접근하도록 락을 거는 방식입니다.  
> **세마포**는 공유 자원에 접근할 수 있는 스레드의 개수를 정수 값으로 제한합니다.  
> 카운팅 세마포어는 여러 스레드의 접근을 허용할 수 있고, 바이너리 세마포어는 접근 가능한 스레드의 수가 0 또는 1로 제한되어 있기 때문에, 뮤텍스와 유사하게 동작합니다.  
> **모니터**는 공유 자원에 접근하기 위해 정해진 인터페이스를 통해 접근하게 하는 방식입니다.  
> 내부적으로는 한 스레드의 공유 자원 접근이 끝나 락이 해제되면, 스케줄러가 대기 큐에 있는 다음 스레드를 선택해 락을 부여하고 공유 자원에 접근하는 방식으로 동작합니다.
</details>

<details>
<summary><b>교착 상태(DeadLock)에 대해 설명해주세요</b></summary>
  
> 교착 상태는 2개 이상의 프로세스가 서로 상대방의 자원을 기다리며 무한정 대기하는 상황을 말합니다.  
> 교착 상태는 4가지 조건이 만족할 때 발생할 가능성이 있습니다.  
> 
> 1) **상호 배제** - 자원이 상호 배제되어 한 번에 하나의 프로세스만 사용할 수 있는 경우
> 2) **점유와 대기** - 이미 자원을 점유한 프로세스가 다른 자원을 기다리는 경우
> 3) **비선점** - 자원이 비선점되어 다른 프로세스가 강제로 자원을 빼앗지 못하는 경우
> 4) **원형 대기** - 프로세스들이 원형으로 자원을 대기하는 경우
</details>

<details>
<summary><b>교착 상태(DeadLock)의 해결 방법은 어떤 것이 있을까요?</b></summary>
  
> 1) **예방** - 교착 상태를 발생시키는 4가지 조건 중 하나를 충족하지 못하게 예방하는 방법입니다.  
> 2) **회피** - 교착 상태가 한정된 자원의 무분별한 할당으로 인해 발생한다고 간주해, 교착 상태 발생 가능성이 없을 때만 자원을 할당하는 방법입니다.  
> 3) **검출 후 회복** - 운영체제가 주기적으로 교착 상태 발생 여부를 검사하다가 교착 상태가 검출되면 자원 선점을 통해 회복하거나 교착 상태에 놓인 프로세스를 강제 종료해서 회복시키는 방법입니다.
</details>

## 4. CPU 스케줄링
